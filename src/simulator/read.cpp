#include<iostream>#include <fstream>#include<cstdio>#include<vector>#include<string>#include "hash.h"#include <utility>#include <assert.h>#include <ctype.h>#include "ir/ir.cpp"#include "ir/wire.h"#include "ir/instruction.h"#include "asem.h"using namespace std;static string reserved[] ={  "rule",  "stage","false","true","enum","const","width",  "size","type","index","read","write","wire","pipe_line",  "register","like","override","alias","function_unit",  "instruction","top","select","code","do","binary","switch"};static int string2int(string & s){  int r(0);  for(int i=0;i<s.length();++i)    r=r*10+s[i]-'0';  return r;}hash_control hc_unfold_read;vector<vector<triple > > unfolded_list_read;vector<string> unfolded_list_name_read;// name of rule of corresponding unfolded_listclass hash_control hc_read;class hash_control & Asem::hc_unfold=hc_unfold_read;vector<vector<triple > > & Asem::unfolded_list=unfolded_list_read;vector<string> & Asem::unfolded_list_name=unfolded_list_name_read;// name of rule of corresponding unfolded_listclass hash_control & Asem::hc=hc_read;int main(){  FILE * input=fopen("in.txt","r");  Asem asem;  asem.type=type_is_vector;  // 读入文件  asem.gen(input);    //asem.display(0);  // 把保留字加入hash表  for(int i=0;i<sizeof(reserved)/sizeof(reserved[0]);++i)    asem.hc.insert(reserved[i].c_str(),(void*)reserved);    // 插入hash表  asem.dfs_insert_hash("");  // instruction里必须有顶层规则  //string instr="...instruction.top";  //assert(hc.find(instr)!=0);  //找到instruction那一项  Asem &instruction=*(asem.ivec[0].find((string)"instruction"));  //找到instruction中的top  Asem &top=*(instruction.find((string)"top"));  Asem &rule=*instruction.find(top.ivec[1].name);  //查看结果  int allrule=rule.unfold();  cout<<rule.unfolded_list[allrule].size()<<endl;  fstream out_txt("out.txt");  hash_control tmp;  for(int i=0;i<rule.unfolded_list[allrule].size();++i)    {      out_txt<<i<<endl<<"\tcode: "<<rule.unfolded_list[allrule][i].code<<endl  	     <<"\tbinary: "<<rule.unfolded_list[allrule][i].binary<<endl;      out_txt<<"do: "<<endl;      // for(int i=0;i<rule.unfolded_list[allrule][i].doo.size();++i)      // 	out_txt<<rule.unfolded_list[allrule][i].doo[i]<<' ';      out_txt<<endl;      for(int i=0;i<rule.unfolded_list[allrule][i].off_in_code.size();++i)  	out_txt<<rule.unfolded_list[allrule][i].off_in_code[i]<<' '<<rule.unfolded_list[allrule][i].off_in_binary[i]<<' ';      out_txt<<endl;    }  //接下来是输出到为ir  //处理wire描述  Ir ir;  Asem &asem_wire=*asem.ivec[0].find((string)"wire");  assert(asem_wire.type==type_is_vector);  Asem &asem_type=*asem.ivec[0].find((string)"type");  assert(asem_type.type==type_is_vector);  for(int i=1;i<asem_wire.ivec.size();++i)    {      string wire_type_name=(*asem_wire.ivec[i].find((string)"width")).ivec[1].name;      //TODO 没有检查type对应的数据类型应该是无符号，查找过程加入出错检查      int wire_width=string2int((*(*(asem_type.find(wire_type_name))).find((string) "width")).ivec[1].name);      ir.add_wire(Wire(asem_wire.ivec[i].ivec[0].name,wire_width));    }  ofstream out2_txt("out2.txt");  ir.output_wire(out2_txt);  // 把code和binary加入到ir里  for(vector<triple>::iterator ite=rule.unfolded_list[allrule].begin();      ite!=rule.unfolded_list[allrule].end();++ite)    {      vector<pp> tmp;      for(int i=0;i<ite->off_in_code.size();++i)  	tmp.push_back(pp(ite->off_in_code[i],ite->off_in_binary[i]));      ir.add_instruction(ite->code,ite->binary,ite->doo,tmp,ite->enum_name,ite->arg_list);    }  ir.output_instruction_set(out2_txt);  return 0;}